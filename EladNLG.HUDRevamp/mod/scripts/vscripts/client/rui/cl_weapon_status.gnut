global function ClWeaponStatus_Init
global function ClWeaponStatus_SetOffhandVisible
global function ClWeaponStatus_SetWeaponVisible
global function ClWeaponStatus_GetWeaponHudRui
global function ClWeaponStatus_RefreshWeaponStatus
global function UpdateOffhandUIPrefab
global function GetOffhandUI
global function TestRuiTopo

global struct TopoData {
    vector position = Vector( 0.0, 0.0, 0.0 )
    vector size = Vector( 0.0, 0.0, 0.0 )
    vector angles = Vector( 0.0, 0.0, 0.0 )
    var topo
}

global struct BarTopoData {
    vector position = Vector( 0.0, 0.0, 0.0 )
    vector size = Vector( 0.0, 0.0, 0.0 )
    vector angles = Vector( 0.0, 0.0, 0.0 )
    int segments = 1
	float segmentDistance
    array<var> imageRuis
    array<TopoData> topoData
    int direction
	float fill
}

global enum eDirection 
{
    down, 
    up,
    left,
    right
}

struct
{
	bool isVisible
	array< void functionref( float ) > updateCallbacks
	array< void functionref() > startCallbacks

	table<string, var> ruis
	table< string, table<string, BarTopoData> > offhandUIPrefabs
	entity selectedWeapon = null
	float curHealthAlpha = 0.9
	float curShieldAlpha = 0.0
} file

struct {
	vector healthPos = Vector(0.0, -0.2875, 0.0)
    vector shieldPos = Vector(0.0, -0.34, 0.0)

    string abilityText = "%.1f"

} settings

void function ClWeaponStatus_Init()
{
	if (IsLobby())
		return
	AddCallback_OnClientScriptInit( ClWeaponStatus_AddClient )
	AddCallback_OnSelectedWeaponChanged( OnSelectedWeaponChanged )

	AddCallback_OnPlayerLifeStateChanged( OnLifeStateChanged )
	AddCallback_PlayerClassChanged( OnPlayerClassChanged )

	AddCallback_KillReplayEnded( OnKillReplayEnded )
}

void function AddStartCallback( void functionref() callback )
{
	file.startCallbacks.append(callback)
}

void function AddUpdateCallback( void functionref( float ) callback )
{
	file.updateCallbacks.append(callback)
}

void function ClWeaponStatus_RefreshWeaponStatus( entity player )
{
	
}

var function ClWeaponStatus_GetWeaponHudRui( entity player, entity weapon )
{
	return null
}

void function ClWeaponStatus_AddClient( entity player )
{
	AddStartCallback( InitAmmoCounterRui )
	AddStartCallback( InitHolsteredWeapons )
	AddStartCallback( InitOffhandRuis )
	AddStartCallback( InitHealthRuis )
	Start()
	thread UpdateThread()
}



// BASIC THREADS

void function Start()
{
	foreach(void functionref() f in file.startCallbacks){
		f()
	}
}

void function UpdateThread()
{
	float time = Time()
	while (true)
	{
		time = Time()
		WaitFrame()
		if (IsWatchingKillReplay()) continue
		foreach(void functionref(float) f in file.updateCallbacks){
			f(Time() - time)
		}
		//while (IsWatchingKillReplay()) { WaitFrame(); }
	}
}

// DAMAGE TAKEN EVENT

// HEALTH AND SHIELD

void function InitHealthRuis()
{
	{
		var rui = RuiCreate( $"ui/cockpit_console_text_center.rpak", clGlobal.topoTitanCockpitHud, RUI_DRAW_COCKPIT, 5 )
		RuiSetInt( rui, "maxLines", 1 )
		RuiSetInt( rui, "lineNum", 1 )
		RuiSetFloat2( rui, "msgPos", settings.healthPos )
		RuiSetFloat3( rui, "msgColor", GetConVarFloat3("comp_hud_accent_color") / 255.0 )
		RuiSetString( rui, "msgText", "10000" )
		RuiSetFloat( rui, "msgFontSize", 32.0 )
		RuiSetFloat( rui, "msgAlpha", 0.9 )
		RuiSetFloat( rui, "thicken", 0.0 )
		file.ruis["health"] <- rui
	}
	{
		var rui = RuiCreate( $"ui/cockpit_console_text_center.rpak", clGlobal.topoTitanCockpitHud, RUI_DRAW_COCKPIT, 5 )
		RuiSetInt( rui, "maxLines", 1 )
		RuiSetInt( rui, "lineNum", 1 )
		RuiSetFloat2( rui, "msgPos", settings.shieldPos )
		RuiSetFloat3( rui, "msgColor", <0.33, 0.6, 1> )
		RuiSetString( rui, "msgText", "2500" )
		RuiSetFloat( rui, "msgFontSize", 32.0 )
		RuiSetFloat( rui, "msgAlpha", 0.9 )
		RuiSetFloat( rui, "thicken", 0.0 )
		file.ruis["shield"] <- rui
	}
	AddUpdateCallback( UpdateHealthDisplays )
}

float lastShieldStateChangeTime = -5.0;
int lastShieldHealth = 0;
void function UpdateHealthDisplays( float deltaTime )
{
	entity player = GetLocalViewPlayer()

	if (!IsValid(player)) return
	if (!IsAlive(player))
	{
		RuiSetFloat( file.ruis["health"], "msgAlpha", 0.0 )
		RuiSetFloat( file.ruis["shield"], "msgAlpha", 0.0 )
	}
	else
	{
		int shieldHealth = 0;
		if (player.GetTitanSoul() != null) shieldHealth = player.GetTitanSoul().GetShieldHealth()
		RuiSetFloat3( file.ruis["health"], "msgColor", GetConVarFloat3("comp_hud_accent_color") / 255.0 )
		RuiSetFloat( file.ruis["health"], "msgAlpha", player.IsTitan() ? 0.9 : 0.0 )
		RuiSetFloat2( file.ruis["health"], "msgPos", settings.healthPos + (GetConVarBool("comp_hud_healthbar_overlap") ? <0.0, -0.0225, 0.0> : <0,0,0>))
		if (shieldHealth > 0)
		{
			if (lastShieldHealth <= 0)
			{
				lastShieldHealth = 1;
				lastShieldStateChangeTime = Time()
			}

			RuiSetFloat( file.ruis["shield"], "msgAlpha", 0.9 )
		}
		else 
		{
			if (lastShieldHealth > 0)
			{
				lastShieldHealth = 0;
				lastShieldStateChangeTime = Time()
			}

			RuiSetFloat( file.ruis["shield"], "msgAlpha", 0.0 )
		}
		RuiSetString(file.ruis["shield"], "msgText", shieldHealth.tostring())
	}

	RuiSetString(file.ruis["health"], "msgText", player.GetHealth().tostring())
}

float function LerpFloat( float a, float b, float t)
{
	t = clamp(t, 0.0, 1.0)
	return ((b - a) * t) + a
}

// MAIN AMMO COUNTER

void function InitAmmoCounterRui()
{
	var rui = RuiCreate( $"ui/cockpit_console_text_center.rpak", clGlobal.topoCockpitHud, RUI_DRAW_COCKPIT, 0 )
	RuiSetInt( rui, "maxLines", 1 )
	RuiSetInt( rui, "lineNum", 1 )
	RuiSetFloat2( rui, "msgPos", GetConVarFloat2("comp_hud_ammo_pos") )
	RuiSetString( rui, "msgText", "56" )
	RuiSetFloat( rui, "msgFontSize", 96.0 )
	RuiSetFloat( rui, "msgAlpha", 0.9 )
	RuiSetFloat( rui, "thicken", 0.0 )
	file.ruis["ammo"] <- rui
	AddUpdateCallback( UpdateAmmoCounter )

	// "AMMO" below the counter
	rui = RuiCreate( $"ui/cockpit_console_text_center.rpak", clGlobal.topoCockpitHud, RUI_DRAW_COCKPIT, 0 )
	RuiSetInt( rui, "maxLines", 1 )
	RuiSetInt( rui, "lineNum", 1 )
	RuiSetFloat2( rui, "msgPos", GetConVarFloat2("comp_hud_ammo_pos") + <0.0, 0.1, 0.0> )
	RuiSetString( rui, "msgText", "AMMO" )
	RuiSetFloat( rui, "msgFontSize", 48.0 )
	RuiSetFloat( rui, "msgAlpha", 0.9 )
	RuiSetFloat( rui, "thicken", 0.0 )

	file.ruis["ammoDisplay"] <- rui
	
	rui = RuiCreate( $"ui/cockpit_console_text_center.rpak", clGlobal.topoCockpitHud, RUI_DRAW_COCKPIT, 0 )
	RuiSetInt( rui, "maxLines", 1 )
	RuiSetInt( rui, "lineNum", 0 )
	RuiSetFloat2( rui, "msgPos", GetConVarFloat2("comp_hud_ammo_pos") + <0.025, 0.1, 0.0> )
	RuiSetString( rui, "msgText", "240" )
	RuiSetFloat( rui, "msgFontSize", 48.0 )
	RuiSetFloat( rui, "msgAlpha", 0.9 )
	RuiSetFloat( rui, "thicken", -0.5 )

	file.ruis["stockpile"] <- rui
}

void function UpdateAmmoCounter( float deltaTime )
{
	entity player = GetLocalViewPlayer()

	if (!IsValid(player)) return
	
	entity weapon = file.selectedWeapon

	if (!IsValid(weapon)) return

	// do not update ammo counter when holding offhand weapon
	foreach(entity w in player.GetOffhandWeapons()){
		if (weapon == w) return
	}

	RuiSetString(file.ruis["ammo"], "msgText", GetAmmoString(weapon))
	
	// REAL-TIME SETTING - COLOR
	RuiSetFloat3(file.ruis["ammo"], "msgColor", 
		(weapon.GetWeaponSettingBool( eWeaponVar.is_burn_mod ) ? GetConVarFloat3("comp_hud_boost_text_color") / 255.0 : GetConVarFloat3("comp_hud_accent_color") / 255.0))
	RuiSetFloat3(file.ruis["ammoDisplay"], "msgColor", 
		(weapon.GetWeaponSettingBool( eWeaponVar.is_burn_mod ) ? GetConVarFloat3("comp_hud_boost_text_color") / 255.0 : GetConVarFloat3("comp_hud_accent_color") / 255.0))
	RuiSetFloat3(file.ruis["stockpile"], "msgColor", 
		(weapon.GetWeaponSettingBool( eWeaponVar.is_burn_mod ) ? GetConVarFloat3("comp_hud_boost_text_color") / 255.0 : GetConVarFloat3("comp_hud_accent_color") / 255.0))
	
	// REAL-TIME SETTING - POSITION
	RuiSetFloat2( file.ruis["ammo"], "msgPos", GetConVarFloat2("comp_hud_ammo_pos") )
	RuiSetFloat2( file.ruis["ammoDisplay"], "msgPos", GetConVarFloat2("comp_hud_ammo_pos") + <0.0, 0.1, 0.0> )
	RuiSetFloat2( file.ruis["stockpile"], "msgPos", GetConVarFloat2("comp_hud_ammo_pos") + <0.025, 0.1, 0.0> )
}

// HOLSTERED WEAPONS

void function InitHolsteredWeapons()
{
	{
		var rui = RuiCreate( $"ui/cockpit_console_text_top_left.rpak", clGlobal.topoCockpitHud, RUI_DRAW_COCKPIT, 0 )
		RuiSetInt( rui, "maxLines", 1 )
		RuiSetInt( rui, "lineNum", 1 )
		RuiSetFloat2( rui, "msgPos", GetConVarFloat2("comp_hud_holstered_weapons_pos") - <0.0, 0.025, 0.0> )
		//RuiSetString( rui, "msgText", "P2016 - 13" )
		RuiSetFloat3( rui, "msgColor", GetConVarFloat3("comp_hud_accent_color") / 255.0 )
		RuiSetFloat( rui, "msgFontSize", 32.0 )
		RuiSetFloat( rui, "msgAlpha", 0.9 )
		RuiSetFloat( rui, "thicken", -0.25 )
		file.ruis["secondary"] <- rui
	}

	{
		var rui = RuiCreate( $"ui/cockpit_console_text_top_left.rpak", clGlobal.topoCockpitHud, RUI_DRAW_COCKPIT, 0 )
		RuiSetInt( rui, "maxLines", 1 )
		RuiSetInt( rui, "lineNum", 1 )
		RuiSetFloat2( rui, "msgPos", GetConVarFloat2("comp_hud_holstered_weapons_pos") + <0.0, 0.025, 0.0> )
		//RuiSetString( rui, "msgText", "CHARGE RIFLE - 22" )
		RuiSetFloat3( rui, "msgColor", GetConVarFloat3("comp_hud_accent_color") / 255.0 )
		RuiSetFloat( rui, "msgFontSize", 32.0 )
		RuiSetFloat( rui, "msgAlpha", 0.9 )
		RuiSetFloat( rui, "thicken", -0.25 )
		file.ruis["weapon3"] <- rui
	}

	AddUpdateCallback( UpdateHolsteredWeapons )
}

void function UpdateHolsteredWeapons( float deltaTime )
{
	entity weapon = file.selectedWeapon
	if (!IsValid(weapon)) return
	entity player = weapon.GetOwner()
	if (!IsValid(player)) return
	if (player != GetLocalClientPlayer()) return
	foreach(entity w in player.GetOffhandWeapons()){
		if (weapon == w) return
	}

	int selectedSlot = 0;

	foreach(entity w in player.GetMainWeapons()){
		if (weapon == w) break
		selectedSlot++
	}

	{
		var rui = file.ruis["secondary"]
		if (player.GetMainWeapons().len() > 1) {
			switch (selectedSlot)
			{
				// display secondary
				case 0:
					entity displayWeapon = player.GetMainWeapons()[1]
					RuiSetFloat3(rui, "msgColor", 
						(displayWeapon.GetWeaponSettingBool( eWeaponVar.is_burn_mod ) ? GetConVarFloat3("comp_hud_boost_text_color") / 255.0 : GetConVarFloat3("comp_hud_accent_color") / 255.0))
					RuiSetString(rui, "msgText", (GetConVarBool("hud_setting_showButtonHints") ? "%weaponSelectPrimary1% " : "") + (displayWeapon.GetReloadMilestoneIndex() != 0 ? "`2" : "") + displayWeapon.GetWeaponSettingString( eWeaponVar.shortprintname ) + (displayWeapon.GetReloadMilestoneIndex() != 0 ? "" : " - " + GetAmmoString(displayWeapon)))
					break
				// display primary
				default:
					entity displayWeapon = player.GetMainWeapons()[0] 
					RuiSetFloat3(rui, "msgColor", 
						(displayWeapon.GetWeaponSettingBool( eWeaponVar.is_burn_mod ) ? GetConVarFloat3("comp_hud_boost_text_color") / 255.0 : GetConVarFloat3("comp_hud_accent_color") / 255.0))
					RuiSetString(rui, "msgText", (GetConVarBool("hud_setting_showButtonHints") ? "%weaponSelectPrimary0% " : "") + (displayWeapon.GetReloadMilestoneIndex() != 0 ? "`2" : "") + displayWeapon.GetWeaponSettingString( eWeaponVar.shortprintname ) + (displayWeapon.GetReloadMilestoneIndex() != 0 ? "" : " - " + GetAmmoString(displayWeapon)))
					break

			}
			RuiSetFloat2( rui, "msgPos", GetConVarFloat2("comp_hud_holstered_weapons_pos") - <0.0, 0.025, 0.0> )
		}
		else
		{
			RuiSetString(rui, "msgText", "")
		}
	}
	{
		var rui = file.ruis["weapon3"]
		if (player.GetMainWeapons().len() > 2) {
			switch (selectedSlot)
			{
				// display secondary
				case 2:
					entity displayWeapon = player.GetMainWeapons()[1] 
					RuiSetFloat3(rui, "msgColor", 
						(displayWeapon.GetWeaponSettingBool( eWeaponVar.is_burn_mod ) ? GetConVarFloat3("comp_hud_boost_text_color") / 255.0 : GetConVarFloat3("comp_hud_accent_color") / 255.0))
					RuiSetString(rui, "msgText", (GetConVarBool("hud_setting_showButtonHints") ? "%weaponSelectPrimary1% " : "") + (displayWeapon.GetReloadMilestoneIndex() != 0 ? "`2" : "") + displayWeapon.GetWeaponSettingString( eWeaponVar.shortprintname ) + (displayWeapon.GetReloadMilestoneIndex() != 0 ? "" : " - " + GetAmmoString(displayWeapon)))
					break
				// display anti-titan
				default:
					entity displayWeapon = player.GetMainWeapons()[2] 
					RuiSetFloat3(rui, "msgColor", 
						(displayWeapon.GetWeaponSettingBool( eWeaponVar.is_burn_mod ) ? GetConVarFloat3("comp_hud_boost_text_color") / 255.0 : GetConVarFloat3("comp_hud_accent_color") / 255.0))
					RuiSetString(rui, "msgText", (GetConVarBool("hud_setting_showButtonHints") ? "%weaponSelectPrimary2% " : "") + (displayWeapon.GetReloadMilestoneIndex() != 0 ? "`2" : "") + displayWeapon.GetWeaponSettingString( eWeaponVar.shortprintname ) + (displayWeapon.GetReloadMilestoneIndex() != 0 ? "" : " - " + GetAmmoString(displayWeapon)))
					break

			}
			RuiSetFloat2( rui, "msgPos", GetConVarFloat2("comp_hud_holstered_weapons_pos") + <0.0, 0.025, 0.0> )
		}
		else
		{
			RuiSetString(rui, "msgText", "")
		}
	}
}

void function OnSelectedWeaponChanged( entity selectedWeapon )
{
	foreach(entity w in GetLocalViewPlayer().GetOffhandWeapons()){
		if (selectedWeapon == w) return
	}
	file.selectedWeapon = selectedWeapon
}

// UTILITY

string function GetAmmoString( entity weapon )
{
	string result
	if (!weapon.GetWeaponSettingBool( eWeaponVar.ammo_no_remove_from_stockpile ))
	{
		if (weapon.GetWeaponSettingInt( eWeaponVar.ammo_clip_size ) <= 1)
		{
			if (file.selectedWeapon == weapon) RuiSetFloat(file.ruis["stockpile"], "msgAlpha", 0.0)
			return (weapon.GetWeaponPrimaryAmmoCount() + weapon.GetWeaponPrimaryClipCount()).tostring()
		}
		if (file.selectedWeapon == weapon) {
			RuiSetString(file.ruis["ammoDisplay"], "msgText", "AMMO")
			RuiSetFloat(file.ruis["stockpile"], "msgAlpha", 0.9)
			RuiSetString(file.ruis["stockpile"], "msgText", weapon.GetWeaponPrimaryAmmoCount().tostring())
		}
		else return weapon.GetWeaponPrimaryClipCount().tostring() + "|`1" + weapon.GetWeaponPrimaryAmmoCount().tostring()

		result = weapon.GetWeaponPrimaryClipCount().tostring()
		int digits = result.len()

		result += "|"

		for (int i = 0; i < digits; i++)
		{
			result += " "
		}

		return result;
	}
	else
	{
			if (file.selectedWeapon == weapon) RuiSetFloat(file.ruis["stockpile"], "msgAlpha", 0.0)
		if (weapon.GetWeaponSettingFloat(eWeaponVar.regen_ammo_refill_rate) > 0.0)
		{
			float ammoFrac = float( weapon.GetWeaponPrimaryClipCount() ) / float( weapon.GetWeaponPrimaryClipCountMax() )

			if (file.selectedWeapon == weapon) RuiSetString(file.ruis["ammoDisplay"], "msgText", "HEAT")

			return int(RoundToNearestInt(100.0 - (ammoFrac * 100.0))).tostring() + "%"
		}
		else if (file.selectedWeapon == weapon) RuiSetString(file.ruis["ammoDisplay"], "msgText", "AMMO")
	}
	return weapon.GetWeaponPrimaryClipCount().tostring()
}

// could be useful, but we are already checking for weapon changed, so?
void function OnPlayerClassChanged( entity player )
{
	
}

// destroy all ruis when dead after doing life checks
void function OnLifeStateChanged( entity player, int oldLifeState, int newLifeState )
{
	
}

void function InitOffhandRuis()
{
	// TEXTS
	{
		var rui = RuiCreate( $"ui/cockpit_console_text_center.rpak", clGlobal.topoCockpitHud, RUI_DRAW_COCKPIT, 0 )
		RuiSetInt( rui, "maxLines", 1 )
		RuiSetInt( rui, "lineNum", 0 )
		RuiSetFloat2( rui, "msgPos", GetConVarFloat2("comp_hud_ordnance_position") + GetConVarFloat2("comp_hud_ability_cooldown_pos_offset") )
		RuiSetString( rui, "msgText", "5" )
		RuiSetFloat( rui, "msgFontSize", 32.0 )
		RuiSetFloat( rui, "msgAlpha", 0.9 )
		RuiSetFloat( rui, "thicken", -0.25 )
		file.ruis["offhand0"] <- rui
	}

	{
		var rui = RuiCreate( $"ui/cockpit_console_text_center.rpak", clGlobal.topoCockpitHud, RUI_DRAW_COCKPIT, 0 )
		RuiSetInt( rui, "maxLines", 1 )
		RuiSetInt( rui, "lineNum", 0 )
		RuiSetFloat2( rui, "msgPos", GetConVarFloat2("comp_hud_tactical_position") + GetConVarFloat2("comp_hud_ability_cooldown_pos_offset") )
		RuiSetString( rui, "msgText", "3" )
		RuiSetFloat( rui, "msgFontSize", 32.0 )
		RuiSetFloat( rui, "msgAlpha", 0.9 )
		RuiSetFloat( rui, "thicken", -0.25 )
		file.ruis["offhand1"] <- rui
	}

	{
		var rui = RuiCreate( $"ui/cockpit_console_text_center.rpak", clGlobal.topoCockpitHud, RUI_DRAW_COCKPIT, 0 )
		RuiSetInt( rui, "maxLines", 1 )
		RuiSetInt( rui, "lineNum", 0 )
		RuiSetFloat2( rui, "msgPos", GetConVarFloat2("comp_hud_utility_position") + GetConVarFloat2("comp_hud_ability_cooldown_pos_offset") )
		RuiSetString( rui, "msgText", "0.9" )
		RuiSetFloat( rui, "msgFontSize", 32.0 )
		RuiSetFloat( rui, "msgAlpha", 0.9 )
		RuiSetFloat( rui, "thicken", -0.25 )
		file.ruis["offhand2"] <- rui
	}

	{
		var rui = RuiCreate( $"ui/cockpit_console_text_top_left.rpak", clGlobal.topoCockpitHud, RUI_DRAW_COCKPIT, 0 )
		RuiSetInt( rui, "maxLines", 1 )
		RuiSetInt( rui, "lineNum", 1 )
		RuiSetFloat2( rui, "msgPos", <0.01, 0.56, 0.0> )
		RuiSetFloat3( rui, "msgColor", GetConVarFloat3("comp_hud_boost_text_color") / 255.0 )
		RuiSetString( rui, "msgText", "BOOST" )
		RuiSetFloat( rui, "msgFontSize", 32.0 )
		RuiSetFloat( rui, "msgAlpha", 0.9 )
		RuiSetFloat( rui, "thicken", -0.25 )
		file.ruis["offhand4"] <- rui
	}

	// BARS
	{
		table<string, BarTopoData> prefab = BasicImageBar_CreateOffhandUI(GetConVarFloat2("comp_hud_ordnance_position"))
		file.offhandUIPrefabs["offhand0"] <- prefab
		thread BasicImageBar_UpdateOffhandUI( prefab, "comp_hud_ordnance_position", 0 )
	}

	{
		table<string, BarTopoData> prefab = BasicImageBar_CreateOffhandUI(GetConVarFloat2("comp_hud_tactical_position"))
		file.offhandUIPrefabs["offhand1"] <- prefab
		thread BasicImageBar_UpdateOffhandUI( prefab, "comp_hud_tactical_position", 1 )
	}

	{
		table<string, BarTopoData> prefab = BasicImageBar_CreateOffhandUI(GetConVarFloat2("comp_hud_utility_position"))
		file.offhandUIPrefabs["offhand2"] <- prefab
		thread BasicImageBar_UpdateOffhandUI( prefab, "comp_hud_utility_position", 2 )
	}


	AddUpdateCallback( UpdateOffhandRuis )
}

void function UpdateOffhandRuis( float deltaTime )
{
	entity player = GetLocalViewPlayer()
	if (!IsValid(player)) return
	for (int i = 0; i < 3; i++)
	{
		var rui = file.ruis["offhand" + i]
		table<string, BarTopoData> bar = file.offhandUIPrefabs["offhand" + i]


		if (!IsValid(player.GetOffhandWeapon(i)))
		{
			foreach ( BarTopoData data in bar )
			{
				BasicImageBar_SetFillFrac( data, 0.0 )
			}
			RuiSetString(rui, "msgText", "")
		}
		else {
			foreach ( string key, BarTopoData data in bar )
			{
				if (key == "bar") continue
				BasicImageBar_SetFillFrac( data, 1.0 )
			}
			string posConVar = "comp_hud_ordnance_position"
			switch (i)
			{
				case 1:
					posConVar = "comp_hud_tactical_position"
					break
				case 2:
					posConVar = "comp_hud_utility_position"
					break
			}
			RuiSetFloat2( rui, "msgPos", GetConVarFloat2(posConVar) + GetConVarFloat2("comp_hud_ability_cooldown_pos_offset") )

			UpdateOffhandRui(rui, bar, player, player.GetOffhandWeapon(i))
		}
	}

	RuiSetFloat3( file.ruis["offhand4"], "msgColor", GetConVarFloat3("comp_hud_boost_text_color") / 255.0 )
	if (GetConVarBool("sv_cheats"))
	{
		RuiSetString(file.ruis["offhand4"], "msgText", "SV_CHEATS 1")
		return
	}
	if (IsValid(player.GetOffhandWeapon(4)))
	{
		entity boost = player.GetOffhandWeapon(4)

		int segments = 0

		if ( player.IsTitan() )
		{
			segments = player.GetWeaponAmmoStockpile( boost )
			segments += boost.GetWeaponPrimaryClipCount()
		}
		else
		{
			//RuiSetInt( rui, "segments", PlayerInventory_ItemCount( player ) )
			segments = player.GetPlayerNetInt("itemInventoryCount")
		}

		RuiSetString( file.ruis["offhand4"], "msgText", Localize(boost.GetWeaponSettingString( eWeaponVar.readymessage )) + format(" (%i boosts available)", segments) )
	}
	else 
	{
		RuiSetString(file.ruis["offhand4"], "msgText", "")
	}
}

void function OnKillReplayEnded()
{

}

void function UpdateOffhandRui( var rui, table<string, BarTopoData> bar, entity player, entity weapon )
{
	float altCooldown = 0.0
	float timeUntilNextCharge = 0.0
	int maxCharges = 1
	float minFracToUse = 1
	bool doNotSetText = false
	float ammoFrac = 0
	if (weapon.IsChargeWeapon()) ammoFrac = 1 - weapon.GetWeaponChargeFraction()
	if (weapon.GetWeaponPrimaryClipCountMax() > 0) ammoFrac = float(weapon.GetWeaponPrimaryClipCount()) / weapon.GetWeaponPrimaryClipCountMax()
	RuiSetImage( bar["icon"].imageRuis[0], "basicImage", GetWeaponInfoFileKeyFieldAsset_WithMods_Global( weapon.GetWeaponClassName(), weapon.GetMods(), "hud_icon" ) )
	switch ( weapon.GetWeaponInfoFileKeyField( "cooldown_type" ) )
	{
		case "ammo_swordblock":
			ammoFrac = 0
			timeUntilNextCharge = 0
			altCooldown = 0
			break
		
		case "shared_energy":
			int curCost = weapon.GetWeaponCurrentEnergyCost() // 350
			float energy = float( player.GetSharedEnergyCount() )
			float maxEnergy = float( player.GetSharedEnergyTotal() ) // 1000
			float energyRegenRate = player.GetSharedEnergyRegenRate()

			maxCharges = int( maxEnergy ) / curCost
			minFracToUse = float( curCost ) / maxEnergy
			int curCharges = int( energy ) / curCost
			int targetAmmo = (curCharges + 1) * curCost
			timeUntilNextCharge = (targetAmmo - energy) / energyRegenRate
			ammoFrac = (energy / curCost)

			// Ability - 2/2 | 2.5s
			break

		case "shared_energy_drain":
			float energy = float( player.GetSharedEnergyCount() )
			float maxEnergy = float( player.GetSharedEnergyTotal() ) // 1000
			float energyRegenRate = player.GetSharedEnergyRegenRate()
			maxCharges = 1

			minFracToUse = 0.1
			timeUntilNextCharge = (maxEnergy - energy) / energyRegenRate
			ammoFrac = (energy / maxEnergy)


			if (player.GetActiveWeapon() == weapon)
			{
				timeUntilNextCharge = (energy / maxEnergy) * weapon.GetWeaponSettingFloat( eWeaponVar.charge_time )
			}
			break

		case "vortex_drain":
			// display percentage/cooldown
			break

		case "charged_shot":
			float chargeCooldownTime = weapon.GetWeaponSettingFloat( eWeaponVar.charge_cooldown_time )
			timeUntilNextCharge = (1 - ammoFrac) * chargeCooldownTime
			ammoFrac = 1 - weapon.GetWeaponChargeFraction()
			switch (weapon.GetWeaponClassName())
			{
				case "mp_titanweapon_shoulder_rockets":
					minFracToUse = 0.2
					break;
				case "mp_titanweapon_vortex_shield":
					minFracToUse = 0.1
					break;
				default:
					minFracToUse = 1
			}
			break

		case "grapple":
			int ammoClipSize = 100
			float ammoMinToFire = weapon.GetWeaponSettingFloat( eWeaponVar.grapple_power_required )
			float grapplePower = player.GetSuitGrapplePower()
			float grappleRegenRate = 3.0

			if (player.HasPassive( ePassives.PAS_POWER_CELL ))
			{
				// AAAAAAAAAAAA
				grappleRegenRate *= 1.35
			}

			maxCharges = 2
			minFracToUse = 0.5
			if (ammoMinToFire > 0) maxCharges = ammoClipSize / int( ammoMinToFire )
			int curCharges = 0;
			if (ammoMinToFire > 0) curCharges = int( grapplePower ) / int( ammoMinToFire )
			int targetAmmo = (curCharges + 1) * int( ammoMinToFire )
			timeUntilNextCharge = (targetAmmo - grapplePower) / grappleRegenRate
			if (ammoClipSize == grapplePower) timeUntilNextCharge = 0
			ammoFrac = grapplePower / ammoClipSize
			
			break

		case "ammo_instant":
			int cost = weapon.GetWeaponSettingInt( eWeaponVar.shared_energy_cost )
			if (cost > 0)
			{
				float energy = float( player.GetSharedEnergyCount() )
				if (energy < cost)
				{
					float energyRegenRate = player.GetSharedEnergyRegenRate()
					float timeUntilNextCharge = (cost - energy) / energyRegenRate
					if (timeUntilNextCharge > altCooldown)
						altCooldown = timeUntilNextCharge
				}
			} 
		default:
			float refillRate = weapon.GetWeaponSettingFloat( eWeaponVar.regen_ammo_refill_rate )

			float timeUntilNextAttack = weapon.GetNextAttackAllowedTime() - Time()
			if (weapon.GetWeaponSettingFloat( eWeaponVar.fire_duration ) > 0)
			{
				if (timeUntilNextAttack > 1 / weapon.GetWeaponSettingFloat( eWeaponVar.fire_rate ))
				{
					RuiSetFloat3( bar["bg"].imageRuis[0], "basicImageColor", <1, 0.5, 0.0> )
					timeUntilNextCharge = timeUntilNextAttack - 1 / weapon.GetWeaponSettingFloat( eWeaponVar.fire_rate )
					break
				}
			}
			RuiSetFloat3( bar["bg"].imageRuis[0], "basicImageColor", <0, 0, 0> )
			if (timeUntilNextAttack > altCooldown)
			{
				altCooldown = timeUntilNextAttack
			}
			if ( refillRate > 0 || !weapon.IsChargeWeapon())
			{
				//printt( "HUD: ", weapon.GetWeaponClassName(), "using", "refillRate" )
				int ammoClipSize = weapon.GetWeaponSettingInt( eWeaponVar.ammo_clip_size )
				// returns MP setting despite it being 1
				int ammoMinToFire = weapon.GetWeaponSettingInt( eWeaponVar.ammo_min_to_fire )
				//printt(weapon.GetWeaponSettingString(eWeaponVar.printname), "| max ammo:", ammoClipSize, "min to fire:", ammoMinToFire)

				maxCharges = ammoClipSize / ammoMinToFire
				minFracToUse = float( ammoMinToFire ) / ammoClipSize
				int curCharges = weapon.GetWeaponPrimaryClipCount() / ammoMinToFire
				int targetAmmo = (curCharges + 1) * ammoMinToFire
				if (refillRate > 0)
					timeUntilNextCharge = float(targetAmmo - weapon.GetWeaponPrimaryClipCount()) / refillRate
				else timeUntilNextCharge = 0.0
				if (ammoClipSize == weapon.GetWeaponPrimaryClipCount()) timeUntilNextCharge = 0

				
			}
			else
			{
				float chargeCooldownTime = weapon.GetWeaponSettingFloat( eWeaponVar.charge_cooldown_time )
				timeUntilNextCharge = (1 - ammoFrac) * chargeCooldownTime
				switch (weapon.GetWeaponClassName())
				{
					case "mp_titanweapon_shoulder_rockets":
						minFracToUse = 0.2
						break;
					case "mp_titanweapon_vortex_shield":
						minFracToUse = 0.1
						break;
					default:
						minFracToUse = 1
				}
			}
			break
	}
	
	float cooldown = max(timeUntilNextCharge, altCooldown)
	maxCharges = int( max(1, maxCharges) )

	if (maxCharges != bar["bar"].segments)
	{
		BasicImageBar_UpdateSegmentCount(bar["bar"], maxCharges, 0.05)
		BasicImageBar_UpdateSegmentCount(bar["bgBar"], maxCharges, 0.05)
		
	}
	foreach (var rui in bar["bgBar"].imageRuis)
	{
		RuiSetFloat3( rui, "basicImageColor", GetConVarFloat3("comp_hud_accent_color") / 255.0 * 0.5)
		RuiSetFloat( rui, "basicImageAlpha", 0.1) 
	}
	foreach(var rui in bar["bar"].imageRuis)
	{
		RuiSetFloat3(rui, "basicImageColor", GetConVarFloat3("comp_hud_accent_color") / 255.0 )
	}
	BasicImageBar_SetFillFrac(bar["bar"], ammoFrac)
	BasicImageBar_SetFillFrac(bar["bgBar"], ammoFrac % 1.0)
	if (ammoFrac < minFracToUse)
	{
		RuiSetFloat3(bar["bgBar"].imageRuis[maxCharges - 1], "basicImageColor", GetConVarFloat3("comp_hud_ability_bg_bar_empty_color") / 255.0)
		RuiSetFloat3(bar["bar"].imageRuis[maxCharges - 1], "basicImageColor", GetConVarFloat3("comp_hud_ability_bar_empty_color") / 255.0)
	}
	else {
		RuiSetFloat3(bar["bgBar"].imageRuis[maxCharges - 1], "basicImageColor", GetConVarFloat3("comp_hud_accent_color") / 255.0 * 0.5)
		RuiSetFloat3(bar["bar"].imageRuis[maxCharges - 1], "basicImageColor", GetConVarFloat3("comp_hud_accent_color") / 255.0 )
	}
	RuiSetFloat(bar["bg"].imageRuis[0], "basicImageAlpha", GetConVarFloat("comp_hud_ability_bg_alpha"))

	if (!doNotSetText) RuiSetString(rui, "msgText", format(settings.abilityText, cooldown))
	


	if (cooldown == 0.0) {
		RuiSetString(rui, "msgText", "")
		RuiSetFloat3(bar["icon"].imageRuis[0], "basicImageColor", <1.5, 1.5, 1.5>)
		RuiSetFloat(bar["icon"].imageRuis[0], "basicImageAlpha", 3)
	}
	else {
		RuiSetFloat3(bar["icon"].imageRuis[0], "basicImageColor", <1, 1, 1>)
		RuiSetFloat(bar["icon"].imageRuis[0], "basicImageAlpha", 3)
	}
}

var function GetPlayerSetting( entity player, string setting )
{
	return GetPlayerSettingsFieldForClassName( player.GetPlayerSettings(), setting )
}

void function ClWeaponStatus_SetOffhandVisible( int offhandIndex, bool newState )
{
	// ALSO A STUB :D
}

var function GetRuiForIndex( entity player, int offhandIndex )
{
	return null
}

void function ClWeaponStatus_SetWeaponVisible( bool newState )
{
	
} 

void function UpdateOffhandUIPrefab( int slot, table<string, BarTopoData> data )
{
	file.offhandUIPrefabs["offhand" + slot] = data
}

table<string, BarTopoData> function GetOffhandUI(int slot)
{
	return file.offhandUIPrefabs["offhand" + slot]
}

void function TestRuiTopo()
{
	var testTopo = CreateWorldTopo( 
		GetLocalViewPlayer().GetViewModelEntity().GetAttachmentOrigin(GetLocalViewPlayer().GetViewModelEntity().LookupAttachment("muzzle_flash")), GetLocalViewPlayer().GetViewModelEntity().GetAttachmentAngles(GetLocalViewPlayer().GetViewModelEntity().LookupAttachment("muzzle_flash")), 16000, 9000
	)

	var rui = RuiCreate( $"ui/cockpit_console_text_center.rpak", testTopo, RUI_DRAW_WORLD, 5 )
	RuiSetInt( rui, "maxLines", 1 )
	RuiSetInt( rui, "lineNum", 0 )
	//RuiSetFloat2( rui, "msgPos", <0,0,0> )
	RuiSetFloat3( rui, "msgColor", GetConVarFloat3("comp_hud_accent_color") )
	RuiSetString( rui, "msgText", "10000" )
	RuiSetFloat( rui, "msgFontSize", 96.0 )
	RuiSetFloat( rui, "msgAlpha", 0.9 )
	RuiSetFloat( rui, "thicken", 0.0 )

	// no idea if this'll work
	RuiTopology_SetParent( testTopo, GetLocalViewPlayer().GetViewModelEntity() )
}